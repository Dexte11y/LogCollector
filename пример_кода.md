### 1. `cmd/producer/main.go`
```go
package main

import (
    "log"
    "logcollector/internal/producer"
    "logcollector/internal/config"
)

func main() {
    cfg, err := config.LoadConfig()
    if err != nil {
        log.Fatalf("could not load config: %v", err)
    }

    prod := producer.NewProducer(cfg)
    if err := prod.Start(); err != nil {
        log.Fatalf("could not start producer: %v", err)
    }
}
```

### 2. `cmd/consumer/main.go`
```go
package main

import (
    "log"
    "logcollector/internal/consumer"
    "logcollector/internal/config"
)

func main() {
    cfg, err := config.LoadConfig()
    if err != nil {
        log.Fatalf("could not load config: %v", err)
    }

    cons := consumer.NewConsumer(cfg)
    if err := cons.Start(); err != nil {
        log.Fatalf("could not start consumer: %v", err)
    }
}
```

### 3. `cmd/api/main.go`
```go
package main

import (
    "log"
    "logcollector/internal/api"
    "logcollector/internal/config"
)

func main() {
    cfg, err := config.LoadConfig()
    if err != nil {
        log.Fatalf("could not load config: %v", err)
    }

    server := api.NewServer(cfg)
    if err := server.Start(); err != nil {
        log.Fatalf("could not start API server: %v", err)
    }
}
```



### 5. `internal/producer/producer.go`
```go
package producer

import (
    "logcollector/internal/config"
    "logcollector/pkg/kafka"
)

type Producer struct {
    cfg *config.Config
}

func NewProducer(cfg *config.Config) *Producer {
    return &Producer{cfg: cfg}
}

func (p *Producer) Start() error {
    // Initialize Kafka producer here
    kafkaProducer := kafka.NewProducer(p.cfg.Kafka.Brokers, p.cfg.Kafka.Topic)
    return kafkaProducer.Produce()
}
```


### 7. `internal/api/handler.go`
```go
package api

import (
    "net/http"
)

func (s *Server) handleLogs(w http.ResponseWriter, r *http.Request) {
    // Handle incoming log requests
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("Logs received"))
}
```

### 8. `internal/api/router.go`
```go
package api

import (
    "github.com/gorilla/mux"
)

func (s *Server) setupRouter() {
    r := mux.NewRouter()
    r.HandleFunc("/logs", s.handleLogs).Methods("POST")
    s.router = r
}
```

### 9. `internal/api/middleware.go`
```go
package api

import (
    "net/http"
)

func (s *Server) loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Add logging logic here
        next.ServeHTTP(w, r)
    })
}
```


### 11. `internal/storage/redis.go`
```go
package storage

import (
    "github.com/go-redis/redis"
    "logcollector/internal/config"
)

type Redis struct {
    client *redis.Client
}

func NewRedis(cfg *config.RedisConfig) *Redis {
    client := redis.NewClient(&redis.Options{
        Addr:     cfg.Address,
        Password: cfg.Password,
        DB:       cfg.DB,
    })

    return &Redis{client: client}
}
```

### 12. `internal/monitoring/prometheus.go`
```go
package monitoring

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    "net/http"
)

func StartPrometheus() {
    http.Handle("/metrics", promhttp.Handler())
    go http.ListenAndServe(":9090", nil)
}
```

### 13. `internal/monitoring/grafana.go`
```go
package monitoring

// Placeholder for Grafana monitoring integration
```

### 14. `pkg/kafka/producer.go`
```go
package kafka

import (
    "github.com/Shopify/sarama"
    "log"
)

type Producer struct {
    brokers []string
    topic   string
}

func NewProducer(brokers []string, topic string) *Producer {
    return &Producer{brokers: brokers, topic: topic}
}

func (p *Producer) Produce() error {
    config := sarama.NewConfig()
    producer, err := sarama.NewSyncProducer(p.brokers, config)
    if err != nil {
        return err
    }
    defer producer.Close()

    msg := &sarama.ProducerMessage{
        Topic: p.topic,
        Value: sarama.StringEncoder("test message"),
    }

    _, _, err = producer.SendMessage(msg)
    if err != nil {
        return err
    }

    log.Println("Message produced successfully")
    return nil
}
```