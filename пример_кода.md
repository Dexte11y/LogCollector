Конечно! Я предоставлю основные части кода для каждого из файлов в вашей структуре. Обратите внимание, что это будет базовая структура кода, и вам, возможно, придется адаптировать её под ваши конкретные требования и логику приложения.

### 1. `cmd/producer/main.go`
```go
package main

import (
    "log"
    "logcollector/internal/producer"
    "logcollector/internal/config"
)

func main() {
    cfg, err := config.LoadConfig()
    if err != nil {
        log.Fatalf("could not load config: %v", err)
    }

    prod := producer.NewProducer(cfg)
    if err := prod.Start(); err != nil {
        log.Fatalf("could not start producer: %v", err)
    }
}
```

### 2. `cmd/consumer/main.go`
```go
package main

import (
    "log"
    "logcollector/internal/consumer"
    "logcollector/internal/config"
)

func main() {
    cfg, err := config.LoadConfig()
    if err != nil {
        log.Fatalf("could not load config: %v", err)
    }

    cons := consumer.NewConsumer(cfg)
    if err := cons.Start(); err != nil {
        log.Fatalf("could not start consumer: %v", err)
    }
}
```

### 3. `cmd/api/main.go`
```go
package main

import (
    "log"
    "logcollector/internal/api"
    "logcollector/internal/config"
)

func main() {
    cfg, err := config.LoadConfig()
    if err != nil {
        log.Fatalf("could not load config: %v", err)
    }

    server := api.NewServer(cfg)
    if err := server.Start(); err != nil {
        log.Fatalf("could not start API server: %v", err)
    }
}
```

### 4. `internal/config/config.go`
```go
package config

import (
    "gopkg.in/yaml.v2"
    "io/ioutil"
    "log"
)

type Config struct {
    Kafka   KafkaConfig   `yaml:"kafka"`
    Redis   RedisConfig   `yaml:"redis"`
    Postgres PostgresConfig `yaml:"postgres"`
    API     APIConfig     `yaml:"api"`
}

type KafkaConfig struct {
    Brokers []string `yaml:"brokers"`
    Topic   string   `yaml:"topic"`
}

type RedisConfig struct {
    Address  string `yaml:"address"`
    Password string `yaml:"password"`
    DB       int    `yaml:"db"`
}

type PostgresConfig struct {
    Host     string `yaml:"host"`
    Port     int    `yaml:"port"`
    User     string `yaml:"user"`
    Password string `yaml:"password"`
    DBName   string `yaml:"dbname"`
}

type APIConfig struct {
    Port int `yaml:"port"`
}

func LoadConfig() (*Config, error) {
    data, err := ioutil.ReadFile("configs/config.yaml")
    if err != nil {
        return nil, err
    }

    var cfg Config
    if err := yaml.Unmarshal(data, &cfg); err != nil {
        return nil, err
    }

    return &cfg, nil
}
```

### 5. `internal/producer/producer.go`
```go
package producer

import (
    "logcollector/internal/config"
    "logcollector/pkg/kafka"
)

type Producer struct {
    cfg *config.Config
}

func NewProducer(cfg *config.Config) *Producer {
    return &Producer{cfg: cfg}
}

func (p *Producer) Start() error {
    // Initialize Kafka producer here
    kafkaProducer := kafka.NewProducer(p.cfg.Kafka.Brokers, p.cfg.Kafka.Topic)
    return kafkaProducer.Produce()
}
```

### 6. `internal/consumer/consumer.go`
```go
package consumer

import (
    "logcollector/internal/config"
    "logcollector/pkg/kafka"
)

type Consumer struct {
    cfg *config.Config
}

func NewConsumer(cfg *config.Config) *Consumer {
    return &Consumer{cfg: cfg}
}

func (c *Consumer) Start() error {
    // Initialize Kafka consumer here
    kafkaConsumer := kafka.NewConsumer(c.cfg.Kafka.Brokers, c.cfg.Kafka.Topic)
    return kafkaConsumer.Consume()
}
```

### 7. `internal/api/handler.go`
```go
package api

import (
    "net/http"
)

func (s *Server) handleLogs(w http.ResponseWriter, r *http.Request) {
    // Handle incoming log requests
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("Logs received"))
}
```

### 8. `internal/api/router.go`
```go
package api

import (
    "github.com/gorilla/mux"
)

func (s *Server) setupRouter() {
    r := mux.NewRouter()
    r.HandleFunc("/logs", s.handleLogs).Methods("POST")
    s.router = r
}
```

### 9. `internal/api/middleware.go`
```go
package api

import (
    "net/http"
)

func (s *Server) loggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Add logging logic here
        next.ServeHTTP(w, r)
    })
}
```

### 10. `internal/storage/postgres.go`
```go
package storage

import (
    "database/sql"
    _ "github.com/lib/pq"
    "logcollector/internal/config"
)

type Postgres struct {
    db *sql.DB
}

func NewPostgres(cfg *config.PostgresConfig) (*Postgres, error) {
    connStr := "postgres://" + cfg.User + ":" + cfg.Password + "@" + cfg.Host + "/" + cfg.DBName + "?sslmode=disable"
    db, err := sql.Open("postgres", connStr)
    if err != nil {
        return nil, err
    }

    return &Postgres{db: db}, nil
}
```

### 11. `internal/storage/redis.go`
```go
package storage

import (
    "github.com/go-redis/redis"
    "logcollector/internal/config"
)

type Redis struct {
    client *redis.Client
}

func NewRedis(cfg *config.RedisConfig) *Redis {
    client := redis.NewClient(&redis.Options{
        Addr:     cfg.Address,
        Password: cfg.Password,
        DB:       cfg.DB,
    })

    return &Redis{client: client}
}
```

### 12. `internal/monitoring/prometheus.go`
```go
package monitoring

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
    "net/http"
)

func StartPrometheus() {
    http.Handle("/metrics", promhttp.Handler())
    go http.ListenAndServe(":9090", nil)
}
```

### 13. `internal/monitoring/grafana.go`
```go
package monitoring

// Placeholder for Grafana monitoring integration
```

### 14. `pkg/kafka/producer.go`
```go
package kafka

import (
    "github.com/Shopify/sarama"
    "log"
)

type Producer struct {
    brokers []string
    topic   string
}

func NewProducer(brokers []string, topic string) *Producer {
    return &Producer{brokers: brokers, topic: topic}
}

func (p *Producer) Produce() error {
    config := sarama.NewConfig()
    producer, err := sarama.NewSyncProducer(p.brokers, config)
    if err != nil {
        return err
    }
    defer producer.Close()

    msg := &sarama.ProducerMessage{
        Topic: p.topic,
        Value: sarama.StringEncoder("test message"),
    }

    _, _, err = producer.SendMessage(msg)
    if err != nil {
        return err
    }

    log.Println("Message produced successfully")
    return nil
}
```

### 15. `pkg/kafka/consumer.go`
```go
package kafka

import (
    "github.com/Shopify/sarama"
    "log"
)

type Consumer struct {
    brokers []string
    topic   string
}

func NewConsumer(brokers []string, topic string) *Consumer {
    return &Consumer{brokers: brokers, topic: topic}
}

func (c *Consumer) Consume() error {
    config := sarama.NewConfig()
    master, err := sarama.NewConsumer(c.brokers, config)
    if err != nil {
        return err
    }
    defer master.Close()

    consumer, err := master.ConsumePartition(c.topic, 0, sarama.OffsetNewest)
    if err != nil {
        return err
    }
    defer consumer.Close()

    for message := range consumer.Messages() {
        log.Printf("Message received: %s", string(message.Value))
    }

    return nil
}
```

Это основная структура для вашего проекта. Вы можете добавить больше логики и тестов по мере необходимости.